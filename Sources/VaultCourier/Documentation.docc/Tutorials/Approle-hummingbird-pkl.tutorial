@Tutorial(time: 40) {
    @Intro(title: "Todos App with VaultCourier and Pkl") {
        This tutorial picks up where "AppRole with Hummingbird Server" chapter left off. It enhances the consumption of Vault secrets via a Pkl resource reader.

        We will modify the Todo app to consume the secrets via a Pkl configuration file. Furthermore, we will improve the command line tool `admin-vault` to use external configuration files to scale the management of the Vault.

        > Important: This tutorial is deliberately simplified and is intended for illustrative purposes only. Please refer to Hashicorp Vault or Openbao documentation for best practices and production hardening.
        
        ----
        
        ###  Scenario

        Continuing with our staged scenario, the _Imaginary Service Company_ (ISC) is pleased with their new approach to managing secrets using Vault. However, they've identified areas for further improvement.

        Currently, the Todo app retrieves database credentials by specifying the static role name and the Vault path where the database secrets engine is mounted. If either of these values changes, the app must be recompiled.

        Additionally, the application team wants to consolidate configuration parameters into an external file that can be updated as needed. This file should include settings such as host, port, and database name—making deployments more flexible and easier to manage.

        On the other hand, the operations team would like to control the complexity of the Vault configuration. Currently, it's embedded directly in code, but they aim to move it into external configuration files. However, they've realized that using _directly_ raw formats like JSON or YAML don't scale well—especially as the configuration grows and interdependencies emerge. For example, policies often need to reference paths where secret mounts are enabled. Managing such relationships becomes difficult without structure or validation. To address this, the team is exploring modern safer alternatives that offer better modularity and scalability.

        ### Proposed Solution
        
        - Enable the `Pkl` package trait in VaultCourier to load both settings and secrets from a single Pkl (pronounced Pickle) configuration file. This effectively makes Pkl the native configuration format for both the Todos and VaultAdmin apps.
        The Pkl trait extends VaultCourier with custom Vault resource readers, allowing for more flexible and seamless secret consumption.

        - Write Vault provisioning data in Pkl files, organizing the configuration so that each app can reuse shared modules. Use `pkl-gen-swift` to generate the swift code for reading the input Pkl data. This avoids writing a lot of boilerplate code that normally would have been written by hand. 

        Template Pkl files for Vault are available in the [vault-courier-pkl repository](https://github.com/vault-courier/vault-courier-pkl/tree/main/Payloads).
        

        ### What is Pkl? 
        
        Pkl is an embeddable, open-source configuration-as-code language. It offers strong validation, powerful tooling, IDE support, and the ability to render to traditional static configuration formats or generate code in other languages.

        For an introduction to its concepts and use cases, visit the official [Pkl  official website](https://pkl-lang.org/) and [blog](https://pkl-lang.org/blog/index.html).

        > Important: For this tutorial we need the `pkl` and `pkl-gen-swift` binaries installed. Please visit [https://pkl-lang.org](https://pkl-lang.org/main/current/pkl-cli/index.html#installation) for instructions.
    }
    
    @Section(title: "Enable the Pkl package trait") {
        In this section we modify the Hummingbird Todo app to use Pkl as its native configuration format.
        @Steps{
            @Step {
                Add the Swift bindings for `Pkl` and enable the `Pkl` package trait in VaultCourier.
                
                @Code(name: "Package.swift", file: hummingbird.pkl.0.0.0.swift, previousFile:  hummingbird.2.0.1.swift)
            }
            
            @Step {
                In the root Package folder create a new file called `TodoConfig.pkl`. This file defines our configuration for the Todo App.
                
                @Code(name: "TodoConfig.pkl", file:  hummingbird.pkl.0.1.0.pkl, reset: true)
            }
            
            @Step {
                In the same place create another file called `todoConfig.stage.pkl` which "amends" the `TodoConfig.pkl` file. In Pkl, the central mechanism for expressing one (part of a) configuration in terms of another is called _amending_. The `todoConfig.stage.pkl` fills the template defined by the configuration module `TodoConfig.pkl`.
                
                @Code(name: "todoConfig.stage.pkl", file: hummingbird.pkl.0.2.0.pkl)
            }
            
            @Step {
                In particular, note how we define the credentials property. Pkl can read external resources, such as environment variables or text files.
                To read a resource, one uses a `read` expression and passes a resource URI scheme. The `Pkl` package trait enables implementations of the external reader protocol, and we use them here to read a vault secret.
                We use the default resource URI scheme "vault", but it can be customized in the initializer of the VaultReader.
                
                @Code(name: "todoConfig.stage.pkl", file: hummingbird.pkl.0.2.1.pkl, previousFile:  hummingbird.pkl.0.2.0.pkl)
            }
            
            @Step {
                With the `TodoConfig.pkl` in the root folder, run `pkl-gen-swift` command in the listing to generate the input swift data transfer object (DTO) of TodoConfig.
                
                @Code(name: "Terminal", file:  hummingbird.pkl.console.0.0.sh)
            }
            
            @Step {
                Voila! we have generated our DTO to read the configuration
                
                @Code(name: "Sources/App/Gen/TodoConfig.pkl.swift", file:  hummingbird.pkl.0.1.0.swift)
            }
            
            @Step {
                Mark the Pkl bindings `@preconcurrency` and add the `Sendable` annotations.
                
                
                This step may not be needed in the future, but at the moment of writing this tutorial the Pkl bindings are not Swift 6 ready. 
                
                @Code(name: "Sources/App/Gen/TodoConfig.pkl.swift", file:  hummingbird.pkl.0.1.1.swift, previousFile:  hummingbird.pkl.0.1.0.swift)
            }
            
            @Step {
                We create an object which carries the database configuration of the Todo app, and which decodes the returned bytes from the resource reader; it is also a good practice to separate the `pkl.swift` generated DTOs from the apps objects.
                
                @Code(name: "Sources/DatabaseConfig.swift", file:  hummingbird.pkl.0.2.0.swift)
            }
            
            @Step {
                In `Source/Vault.swift` change the signature of `connectToVault` to return `DatabaseConfig` instead of just the `DatabaseCredentials`.
                
                @Code(name: "Source/Vault.swift", file:  hummingbird.pkl.0.3.0.swift, previousFile:  hummingbird.0.1.3.swift)
            }
            
            @Step {
                Replace the direct call to Vault with the creation of a `VaultReader` with URI scheme `vault`. Call `readConfiguration` and return the database configuration
                
                For simplicity we write directly the filepath to the main configuration file, but this can of course be given in the app arguments or in an environment variable.
                
                @Code(name: "Source/Vault.swift", file:  hummingbird.pkl.0.3.1.swift, previousFile:  hummingbird.pkl.0.3.0.swift)
            }
            
            @Step {
                Finally adapt the injection of the database configuration into the Postgres client. With this we have successfully integrated Pkl as our native config format.
                
                @Code(name: "Sources/App/Application+build.swift", file:  hummingbird.pkl.0.4.0.swift, previousFile:  hummingbird.0.2.1.swift)
            }
            
            @Step {
                In order to run the Todo app, we need to tell the Pkl bindings where the `pkl` binary is. You can do this by setting the env variable `PKL_EXEC` or adding the folder containing the binary into the `PATH`.
                
                Great! if you still have the setup lab from the previous tutorial you just need to regenerate new approle credentials and run the app with the `PKL_EXEC` env variable.
                Otherwise, please setup the lab again following the steps in the "Run Lab" section of the _AppRole with Hummingbird server_ tutorial. The instructions are also in the [examples repository](https://github.com/vault-courier/vault-courier-examples/tree/main/approle-hummingbird-example-with-pkl).
                
                @Code(name: "Source/Vault.swift", file:  hummingbird.pkl.console.1.0.sh)
            }
        }
    }
    
<!--    @Section(title: "Vault operations with Pkl") {-->
<!--        In this section...-->
<!--        -->
<!--        @Steps {-->
<!--            @Step {-->
<!--                Create a new executable target with dependencies to Swift `ArgumentParser`, `VaultCourier` and `OpenAPIAsyncHTTPClient`. Create a new subfolder `Sources/Operations`.-->
<!--                -->
<!--                @Code(name: "Package.swift", file: hummingbird.1.0.1.swift, previousFile:  hummingbird.1.0.0.swift)-->
<!--            }-->
<!--            -->
<!--            @Step {-->
<!--                Create a new file in `Sources/Operations/VaultAdmin.swift`. We introduce a main argument parser async command, called `vault-admin` with a vault client static function.-->
<!--                Note that we use the token authentication method, which is usually reserved to privileged roles.-->
<!--                -->
<!--                @Code(name: "Sources/Operations/VaultAdmin.swift", file: hummingbird.1.1.0.swift)-->
<!--            }-->
<!--            -->
<!--            @Step {-->
<!--                We'll introduce two subcommands. The first subcommand `provision` is a one time vault operation to create policies, approles, and configuring the Vault-PostgreSQL connection.-->
<!--                -->
<!--                @Code(name: "Sources/Operations/VaultAdmin.swift", file: hummingbird.1.1.1.swift, previousFile:  hummingbird.1.1.0.swift)-->
<!--            }-->
<!--            -->
<!--            @Step {-->
<!--                Add a function to define the todo and migrator policies. The todo policy grants the Todo app read access to the static database credentials required by the server. The migrator policy allows read access to dynamic credentials needed by the migrator app, which will be implemented in the next section.-->
<!---->
<!--                For simplicity, we're writing the configuration directly here. In a separate tutorial, we'll demonstrate how to scale this setup using [Pkl](https://pkl-lang.org).-->
<!--                -->
<!--                @Code(name: "Sources/Operations/VaultAdmin.swift", file: hummingbird.1.1.2.swift, previousFile:  hummingbird.1.1.1.swift)-->
<!--            }-->
<!--            -->
<!--            @Step {-->
<!--                Add a function to let Vault manage PostgreSQL credentials. Here we create the `static_server_role` for the Todo app (used in Section 1, Step 9),-->
<!--                and create in advance the `dynamic_migrator_role`. We use VaultClient's method ``create(staticRole:enginePath:)`` and ``create(dynamicRole:enginePath:)``-->
<!--                -->
<!--                Note: in a production environment, we'd have a separate vault user different from the root user. After creating the connection, the vault user credentials can be rotated (and are thus only known by the Vault).-->
<!--                -->
<!--                @Code(name: "Sources/Operations/VaultAdmin.swift", file: hummingbird.1.1.3.swift, previousFile:  hummingbird.1.1.2.swift)-->
<!--            }-->
<!--            -->
<!--            @Step {-->
<!--                To complete the provision, we add a function for enabling the `AppRole` authentication method, and create the approles for our apps. We used VaultClient's method ``createAppRole``. This completes the setup for the `provision` subcommand.-->
<!--                -->
<!--                @Code(name: "Sources/Operations/VaultAdmin.swift", file: hummingbird.1.1.4.swift, previousFile:  hummingbird.1.1.3.swift)-->
<!--            }-->
<!--            -->
<!--            @Step {-->
<!--                Next we add a last subcommand `AppRoleCredentials` to generate the approle credentials for our apps-->
<!--                -->
<!--                @Code(name: "Sources/Operations/VaultAdmin.swift", file: hummingbird.1.1.5.swift, previousFile:  hummingbird.1.1.4.swift)-->
<!--            }-->
<!--            -->
<!--            @Step {-->
<!--                Using VaultClient's  method ``generateAppSecretId(capabilities:)`` we add a function which generates the approle credentials depending on the app. Contrary to the `provision` subcommand we can call this function-->
<!--                multiple times. It writes the SecretID into an output text file. The output parameter can be given. For simplicity we print the RoleID into the standard input. This finishes our command line tool.-->
<!--                -->
<!--                To deploy the Todo app, we first need to create the Todos table. We'll do that in the next section.-->
<!--                -->
<!--                @Code(name: "Sources/Operations/VaultAdmin.swift", file: hummingbird.1.1.6.swift, previousFile:  hummingbird.1.1.5.swift)-->
<!--            }-->
<!--        }-->
<!--    }-->

<!--    @Section(title: "Run Lab") {-->
<!--        This last section of this tutorial will set up the lab to run our applications. You need the HashiCorpVault or OpenBao binary installed in your system `PATH`, as well as Docker installed.-->
<!--        -->
<!--        @Steps {-->
<!--            @Step {-->
<!--                Open a terminal and start a Vault dev server with the literal string `education` as the root token value.-->
<!--                -->
<!--                You can alternative, start a `bao` dev server by replacing `vault` with `bao` in the listing.-->
<!--                -->
<!--                @Code(name: "Terminal Tab 1", file: start-vault.console.0.txt, reset: true)-->
<!--            }-->
<!--            -->
<!--            @Step {-->
<!--                Open a **new terminal** and start a PostgreSQL database with docker with a root user named `vault_root` and password `root_password`.-->
<!--                -->
<!--                **Note**: In production, it's important to create a _dedicated role_ for Vault, separate from the general admin role. This allows you to rotate the Vault user's password after setup to avoid relying on the initial credentials — but once rotated, only Vault knows the new password.-->
<!--                Failing to separate these roles can result in the root admin being locked out of the database.-->
<!--                -->
<!--                @Code(name: "Terminal Tab 2", file: hummingbird.console.1.0.sh)-->
<!--            }-->
<!--            -->
<!--            @Step {-->
<!--                Create a database role for the `Todo` app, and grant access to the database.-->
<!--                -->
<!--                @Code(name: "Terminal Tab 2", file: hummingbird.console.1.1.sh, previousFile: hummingbird.console.1.0.sh)-->
<!--            }-->
<!--            -->
<!--            @Step {-->
<!--                In the terminal go to root folder of the modified `todos-postgres-tutorial` and run the `admin-vault` command line tool. First run the provision-->
<!--                -->
<!--                You can of course run this and the following commands in your favourite IDE.-->
<!--                -->
<!--                @Code(name: "Terminal Tab 2", file: hummingbird.console.2.0.sh, reset: true)-->
<!--            }-->
<!--            -->
<!--            @Step {-->
<!--                Run the approle credentials generation for the Migrator app -->
<!--                -->
<!--                @Code(name: "Terminal Tab 2", file: hummingbird.console.2.1.sh, previousFile: hummingbird.console.2.0.sh)-->
<!--            }-->
<!--            -->
<!--            @Step {-->
<!--                Run the the Migrator app. Don't forget to add the Env variables. -->
<!--                -->
<!--                @Code(name: "Terminal Tab 2", file: hummingbird.console.2.2.sh, previousFile: hummingbird.console.2.1.sh)-->
<!--            }-->
<!--            -->
<!--            @Step {-->
<!--                Run the approle credentials generation for the Todo app. -->
<!--                -->
<!--                @Code(name: "Terminal Tab 2", file: hummingbird.console.2.3.sh, previousFile: hummingbird.console.2.2.sh)-->
<!--            }-->
<!--            -->
<!--            @Step {-->
<!--                Run the the Todo app. Again, don't forget to add the Env variables. We have successfully integrated VaultCourier into the Todo app! 🥳-->
<!--                -->
<!--                @Code(name: "Terminal Tab 2", file: hummingbird.console.2.4.sh, previousFile: hummingbird.console.2.3.sh)-->
<!--            }-->
<!--            -->
<!--            @Step {-->
<!--                Open a new Terminal and try creating a Todo. As we can see our App has access to the database.-->
<!--                -->
<!--                You can also open your browser `http://localhost:8080/todos`.-->
<!--                -->
<!--                @Code(name: "Terminal Tab 3", file: hummingbird.console.3.0.sh, reset: true)-->
<!--            }-->
<!--        }-->
<!--    }-->
<!--    -->
<!--    @Section(title: "(Optional) Response Wrapping") {-->
<!--        We can enhance the security of the Todo app deployment by using Vault's response wrapping feature during AppRole credential generation. Currently, the app can be run multiple times using the same randomly generated `SECRET_ID` stored at `SECRET_ID_FILEPATH`, which isn't ideal for production.-->
<!---->
<!--        Instead, we can generate a one-time-use token that wraps the AppRole credentials. This wrapped token can only be used once within a limited time window to retrieve the actual `SECRET_ID`. If someone tries to reuse the wrapped token, Vault will reject it as already unwrapped.-->
<!---->
<!--        The unwrapped `SECRET_ID` can still be reused according to its configured limits. VaultCourier handles the response wrapping process automatically during authentication—we just need to indicate that the credentials are wrapped.-->
<!---->
<!--        Let's add this to the Todo app configuration.-->
<!--        -->
<!--        @Steps {-->
<!--            @Step {-->
<!--                Go To the function that generates the approle credentials in `Sources/Operations/VaultAdmin.swift` and add a wrapTimeToLive duration, say of 60 seconds.-->
<!--                -->
<!--                @Code(name: "Sources/Operations/VaultAdmin.swift", file: hummingbird.1.1.7.swift, previousFile:  hummingbird.1.1.6.swift)-->
<!--            }-->
<!--            -->
<!--            @Step {-->
<!--                Update `Vault.swift` to tell VaultCourier that the credential is wrapped. That's it—now regenerate the credentials using Operations credentials todo and run the app. On a second run, authentication will fail.-->
<!---->
<!--                This mechanism enables malfeasance detection by ensuring only one party can unwrap the token. If a client receives a token that can't be unwrapped, it can trigger an immediate security alert. -->
<!--                -->
<!--                @Code(name: "Sources/App/Vault.swift", file: hummingbird.0.1.4.swift, previousFile:  hummingbird.0.1.3.swift)-->
<!--            }-->
<!--        }-->
<!--    }-->
}
