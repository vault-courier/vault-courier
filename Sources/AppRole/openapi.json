{
  "openapi": "3.0.3",
  "info": {
    "title": "Vault Courier AppRole Authentication API",
    "version": "0.1.0",
    "description": "API client for Hashicorp Vault and OpenBao",
    "license": {
      "name": "Apache License 2.0"
    }
  },
  "servers": [
    {
      "url": "http://127.0.0.1:8200/v1",
      "description": "Default http server url"
    }
  ],
  "paths": {
    "/auth/{engine_path}/role/{role_name}": {
      "description": "Creates a new role",
      "get": {
        "tags": [
          "auth"
        ],
        "summary": "Reads the properties of an existing AppRole.",
        "description": "Reads the properties of an existing AppRole.",
        "operationId": "auth-read-approle",
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ReadAppRoleResponse"
                }
              }
            }
          },
          "400": {
            "description": "BadRequest",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/VaultErrorsResponse"
                }
              }
            }
          }
        }
      },
      "post": {
        "tags": [
          "auth"
        ],
        "summary": "Creates a new AppRole or updates an existing AppRole. AppRole Path defined for MyApp",
        "description": "Creates a new AppRole or updates an existing AppRole. This endpoint supports both create and update capabilities.",
        "operationId": "auth-create-approle",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/AuthCreateAppRoleRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "204": {
            "description": "OK"
          },
          "400": {
            "description": "BadRequest",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/VaultErrorsResponse"
                }
              }
            }
          }
        }
      },
      "delete": {
        "tags": [
          "auth"
        ],
        "summary": "Deletes an existing AppRole from the auth method.",
        "description": "Deletes an existing AppRole",
        "operationId": "auth-delete-approle",
        "responses": {
          "204": {
            "description": "OK"
          },
          "400": {
            "description": "BadRequest",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/VaultErrorsResponse"
                }
              }
            }
          }
        }
      },
      "parameters": [
        {
          "description": "AppRole engine path",
          "name": "engine_path",
          "in": "path",
          "required": true,
          "schema": {
            "type": "string"
          }
        },
        {
          "description": "The name of the approle. Example: \"my-app-role\"",
          "name": "role_name",
          "in": "path",
          "required": true,
          "schema": {
            "type": "string"
          }
        },
        {
          "$ref": "#/components/parameters/VaultTokenHeader"
        }
      ]
    },
    "/auth/{engine_path}/role/{role_name}/role-id": {
      "description": "Reads the role-id of a role",
      "get": {
        "tags": [
          "auth"
        ],
        "summary": "Reads the RoleID of an existing AppRole.",
        "description": "Reads the RoleID of an existing AppRole.",
        "operationId": "auth-read-role-id",
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ReadAppRoleIdResponse"
                }
              }
            }
          },
          "400": {
            "description": "BadRequest",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/VaultErrorsResponse"
                }
              }
            }
          }
        }
      },
      "parameters": [
        {
          "description": "AppRole engine path",
          "name": "engine_path",
          "in": "path",
          "required": true,
          "schema": {
            "type": "string"
          }
        },
        {
          "description": "The name of the approle. Example: \"my-app-role\"",
          "name": "role_name",
          "in": "path",
          "required": true,
          "schema": {
            "type": "string"
          }
        },
        {
          "$ref": "#/components/parameters/VaultTokenHeader"
        }
      ]
    },
    "/auth/{engine_path}/role/{role_name}/secret-id": {
      "description": "Generates and issues a new SecretID on an existing AppRole",
      "post": {
        "tags": [
          "auth"
        ],
        "summary": "Generates and issues a new SecretID on an existing AppRole",
        "description": "Creates a new AppRole or updates an existing AppRole. This endpoint supports both create and update capabilities.",
        "operationId": "auth-approle-secret-id",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/AuthGenerateAppRoleSecretIdRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "anyOf": [
                    {
                      "oneOf": [
                        {
                          "$ref": "#/components/schemas/GenerateAppRoleSecretIdResponse"
                        },
                        {
                          "$ref": "#/components/schemas/VaultWrappedResponse"
                        }
                      ]
                    },
                    {
                      "type": "object"
                    }
                  ]
                }
              }
            }
          },
          "400": {
            "description": "BadRequest",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/VaultErrorsResponse"
                }
              }
            }
          }
        }
      },
      "parameters": [
        {
          "description": "AppRole engine path",
          "name": "engine_path",
          "in": "path",
          "required": true,
          "schema": {
            "type": "string"
          }
        },
        {
          "description": "The name of the approle. Example: \"my-app-role\"",
          "name": "role_name",
          "in": "path",
          "required": true,
          "schema": {
            "type": "string"
          }
        },
        {
          "$ref": "#/components/parameters/VaultTokenHeader"
        },
        {
          "description": "Use the X-Vault-Wrap-TTL header with any Vault API call where you want to wrap the response.",
          "name": "X-Vault-Wrap-TTL",
          "in": "header",
          "required": false,
          "schema": {
            "type": "string"
          }
        }
      ]
    },
    "/auth/{engine_path}/role/{role_name}/secret-id-accessor/lookup": {
      "description": "Reads out the properties of a SecretID via the secret id accessor",
      "post": {
        "tags": [
          "auth"
        ],
        "summary": "Reads out the properties of a SecretID via the secret id accessor",
        "description": "Reads out the properties of a SecretID via the secret id accessor",
        "operationId": "auth-read-approle-secret-id-with-accessor",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "secret_id_accessor": {
                    "type": "string"
                  }
                },
                "required": [
                  "secret_id_accessor"
                ]
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ReadAppRoleSecretIdWithAccessorResponse"
                }
              }
            }
          },
          "400": {
            "description": "BadRequest",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/VaultErrorsResponse"
                }
              }
            }
          }
        }
      },
      "parameters": [
        {
          "description": "AppRole engine path",
          "name": "engine_path",
          "in": "path",
          "required": true,
          "schema": {
            "type": "string"
          }
        },
        {
          "description": "The name of the approle. Example: \"my-app-role\"",
          "name": "role_name",
          "in": "path",
          "required": true,
          "schema": {
            "type": "string"
          }
        },
        {
          "$ref": "#/components/parameters/VaultTokenHeader"
        }
      ]
    },
    "/auth/{engine_path}/role/{role_name}/secret-id-accessor/destroy": {
      "description": "Destroy an AppRole secret ID by its accessor.",
      "post": {
        "tags": [
          "auth"
        ],
        "summary": "Destroy an AppRole secret ID by its accessor.",
        "description": "Destroy an AppRole secret ID by its accessor.",
        "operationId": "auth-destroy-approle-secret-id-with-accessor",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "secret_id_accessor": {
                    "type": "string"
                  }
                },
                "required": [
                  "secret_id_accessor"
                ]
              }
            }
          },
          "required": true
        },
        "responses": {
          "204": {
            "description": "OK"
          },
          "400": {
            "description": "BadRequest",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/VaultErrorsResponse"
                }
              }
            }
          }
        }
      },
      "parameters": [
        {
          "description": "AppRole engine path",
          "name": "engine_path",
          "in": "path",
          "required": true,
          "schema": {
            "type": "string"
          }
        },
        {
          "description": "The name of the approle. Example: \"my-app-role\"",
          "name": "role_name",
          "in": "path",
          "required": true,
          "schema": {
            "type": "string"
          }
        },
        {
          "$ref": "#/components/parameters/VaultTokenHeader"
        }
      ]
    },
    "/auth/{engine_path}/login": {
      "description": "Issues a Vault token based on the presented credentials. `role_id` is always required; if `bind_secret_id` is enabled (the default) on the AppRole, `secret_id` is required too. Any other bound authentication values on the AppRole (such as client IP CIDR) are also evaluated.",
      "post": {
        "tags": [
          "auth"
        ],
        "summary": "Issues a Vault token based on the presented credentials",
        "description": "Issues a Vault token based on the presented credentials. `role_id` is always required; if `bind_secret_id` is enabled (the default) on the AppRole, `secret_id` is required too. Any other bound authentication values on the AppRole (such as client IP CIDR) are also evaluated.",
        "operationId": "auth-approle-login",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "role_id": {
                    "type": "string"
                  },
                  "secret_id": {
                    "type": "string"
                  }
                },
                "required": [
                  "role_id",
                  "secret_id"
                ]
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/VaultAuthResponse"
                }
              }
            }
          },
          "400": {
            "description": "BadRequest",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/VaultErrorsResponse"
                }
              }
            }
          }
        }
      },
      "parameters": [
        {
          "description": "AppRole engine path",
          "name": "engine_path",
          "in": "path",
          "required": true,
          "schema": {
            "type": "string"
          }
        },
        {
          "$ref": "#/components/parameters/VaultTokenHeader"
        }
      ]
    }
  },
  "components": {
    "schemas": {
      "AuthCreateAppRoleRequest": {
        "type": "object",
        "properties": {
          "token_bound_cidrs": {
            "type": "array",
            "description": "List of CIDR blocks; if set, specifies blocks of IP addresses which can authenticate successfully, and ties the resulting token to these blocks as well.",
            "items": {
              "type": "string"
            }
          },
          "token_explicit_max_ttl": {
            "type": "string",
            "description": "If set, will encode an explicit max TTL onto the token. This is a hard cap even if `token_ttl` and `token_max_ttl` would otherwise allow a renewal."
          },
          "token_no_default_policy": {
            "type": "boolean",
            "description": "If set, the default policy will not be set on generated tokens; otherwise it will be added to the policies set in `token_policies`."
          },
          "token_num_uses": {
            "type": "integer",
            "description": "The maximum number of times a generated token may be used (within its lifetime); 0 means unlimited. If you require the token to have the ability to create child tokens, you will need to set this value to 0."
          },
          "token_period": {
            "type": "string",
            "description": "The maximum allowed period value when a periodic token is requested from this role."
          },
          "token_type": {
            "type": "string",
            "description": "The type of token that should be generated. Can be service, batch, or default to use the mount's tuned default (which unless changed will be service tokens). For token store roles, there are two additional possibilities: default-service and default-batch which specify the type to return unless the client requests a different type at generation time. For machine based authentication cases, you should use batch type tokens.",
            "enum": [
              "batch",
              "service",
              "default",
              "default-service",
              "default-batch"
            ]
          },
          "token_ttl": {
            "type": "string",
            "description": "The incremental lifetime for generated tokens. This current value of this will be referenced at renewal time."
          },
          "token_max_ttl": {
            "type": "string",
            "description": "The maximum lifetime for generated tokens. This current value of this will be referenced at renewal time."
          },
          "token_policies": {
            "type": "array",
            "description": "List of token policies to encode onto generated tokens. Depending on the auth method, this list may be supplemented by user/group/other values.",
            "items": {
              "type": "string"
            }
          },
          "bind_secret_id": {
            "type": "boolean",
            "description": "Require `secret_id` to be presented when logging in using this AppRole."
          },
          "secret_id_bound_cidrs": {
            "type": "array",
            "description": "Comma-separated string or list of CIDR blocks; if set, specifies blocks of IP addresses which can perform the login operation.",
            "items": {
              "type": "string"
            }
          },
          "secret_id_num_uses": {
            "type": "integer",
            "description": "Number of times any particular SecretID can be used to fetch a token from this AppRole, after which the SecretID by default will expire. A value of zero will allow unlimited uses. However, this option may be overridden by the request's `num_uses` field when generating a SecretID."
          },
          "secret_id_ttl": {
            "type": "string",
            "description": "Duration in either an integer number of seconds (3600) or an integer time unit (60m) after which by default any SecretID expires. A value of zero will allow the SecretID to not expire. However, this option may be overridden by the request's `ttl` field when generating a SecretID."
          },
          "local_secret_ids": {
            "type": "boolean",
            "description": "If set, the secret IDs generated using this role will be cluster local. This can only be set during role creation and once set, it can't be reset later."
          }
        }
      },
      "ReadAppRoleResponse": {
        "type": "object",
        "properties": {
          "request_id": {
            "type": "string"
          },
          "lease_id": {
            "type": "string"
          },
          "renewable": {
            "type": "boolean"
          },
          "lease_duration": {
            "type": "integer"
          },
          "data": {
            "type": "object",
            "properties": {
              "token_bound_cidrs": {
                "type": "array",
                "description": "List of CIDR blocks; if set, specifies blocks of IP addresses which can authenticate successfully, and ties the resulting token to these blocks as well.",
                "items": {
                  "type": "string"
                }
              },
              "token_explicit_max_ttl": {
                "type": "integer",
                "description": "If set, will encode an explicit max TTL onto the token. This is a hard cap even if `token_ttl` and `token_max_ttl` would otherwise allow a renewal."
              },
              "token_no_default_policy": {
                "type": "boolean",
                "description": "If set, the default policy will not be set on generated tokens; otherwise it will be added to the policies set in `token_policies`."
              },
              "token_num_uses": {
                "type": "integer",
                "description": "The maximum number of times a generated token may be used (within its lifetime); 0 means unlimited. If you require the token to have the ability to create child tokens, you will need to set this value to 0."
              },
              "token_period": {
                "type": "integer",
                "description": "The maximum allowed period value when a periodic token is requested from this role."
              },
              "token_type": {
                "type": "string",
                "description": "The type of token that should be generated. Can be service, batch, or default to use the mount's tuned default (which unless changed will be service tokens). For token store roles, there are two additional possibilities: default-service and default-batch which specify the type to return unless the client requests a different type at generation time. For machine based authentication cases, you should use batch type tokens.",
                "enum": [
                  "batch",
                  "service",
                  "default",
                  "default-service",
                  "default-batch"
                ]
              },
              "token_ttl": {
                "type": "integer",
                "description": "The incremental lifetime for generated tokens. This current value of this will be referenced at renewal time."
              },
              "token_max_ttl": {
                "type": "integer",
                "description": "The maximum lifetime for generated tokens. This current value of this will be referenced at renewal time."
              },
              "token_policies": {
                "type": "array",
                "description": "List of token policies to encode onto generated tokens. Depending on the auth method, this list may be supplemented by user/group/other values.",
                "items": {
                  "type": "string"
                }
              },
              "bind_secret_id": {
                "type": "boolean",
                "description": "Require `secret_id` to be presented when logging in using this AppRole."
              },
              "secret_id_bound_cidrs": {
                "type": "array",
                "description": "Comma-separated string or list of CIDR blocks; if set, specifies blocks of IP addresses which can perform the login operation.",
                "items": {
                  "type": "string"
                }
              },
              "secret_id_num_uses": {
                "type": "integer",
                "description": "Number of times any particular SecretID can be used to fetch a token from this AppRole, after which the SecretID by default will expire. A value of zero will allow unlimited uses. However, this option may be overridden by the request's `num_uses` field when generating a SecretID."
              },
              "secret_id_ttl": {
                "type": "integer",
                "description": "Duration in either an integer number of seconds (3600) or an integer time unit (60m) after which by default any SecretID expires. A value of zero will allow the SecretID to not expire. However, this option may be overridden by the request's `ttl` field when generating a SecretID."
              },
              "local_secret_ids": {
                "type": "boolean",
                "description": "If set, the secret IDs generated using this role will be cluster local. This can only be set during role creation and once set, it can't be reset later."
              }
            }
          },
          "wrap_info": {
            "type": "object"
          },
          "warnings": {
            "type": "array",
            "description": "A list of warnings, e.g. ignored parameters",
            "items": {
              "type": "string"
            }
          },
          "auth": {
            "type": "object"
          },
          "mount_type": {
            "type": "string"
          }
        },
        "required": [
          "request_id",
          "data"
        ]
      },
      "ReadAppRoleIdResponse": {
        "type": "object",
        "properties": {
          "request_id": {
            "type": "string"
          },
          "lease_id": {
            "type": "string"
          },
          "renewable": {
            "type": "boolean"
          },
          "lease_duration": {
            "type": "integer"
          },
          "data": {
            "type": "object",
            "properties": {
              "role_id": {
                "type": "string"
              }
            },
            "required": [
              "role_id"
            ]
          },
          "wrap_info": {
            "type": "object"
          },
          "warnings": {
            "type": "array",
            "description": "A list of warnings, e.g. ignored parameters",
            "items": {
              "type": "string"
            }
          },
          "auth": {
            "type": "object"
          },
          "mount_type": {
            "type": "string"
          }
        },
        "required": [
          "request_id",
          "data"
        ]
      },
      "GenerateAppRoleSecretIdResponse": {
        "type": "object",
        "properties": {
          "request_id": {
            "type": "string"
          },
          "data": {
            "type": "object",
            "properties": {
              "secret_id_accessor": {
                "type": "string"
              },
              "secret_id": {
                "type": "string"
              },
              "secret_id_ttl": {
                "type": "integer"
              },
              "secret_id_num_uses": {
                "type": "integer"
              }
            },
            "required": [
              "secret_id_accessor",
              "secret_id",
              "secret_id_ttl",
              "secret_id_num_uses"
            ]
          }
        },
        "required": [
          "data"
        ]
      },
      "ReadAppRoleSecretIdWithAccessorResponse": {
        "type": "object",
        "properties": {
          "request_id": {
            "type": "string"
          },
          "data": {
            "type": "object",
            "properties": {
              "cidr_list": {
                "type": "array",
                "items": {
                  "type": "string"
                }
              },
              "creation_time": {
                "type": "string"
              },
              "expiration_time": {
                "type": "string"
              },
              "last_updated_time": {
                "type": "string"
              },
              "metadata": {
                "type": "object",
                "format": "kvpairs"
              },
              "secret_id_accessor": {
                "type": "string"
              },
              "secret_id_ttl": {
                "type": "integer"
              },
              "secret_id_num_uses": {
                "type": "integer"
              },
              "token_bound_cidrs": {
                "type": "array",
                "items": {
                  "type": "string"
                }
              }
            },
            "required": [
              "creation_time",
              "secret_id_accessor",
              "secret_id_ttl",
              "secret_id_num_uses"
            ]
          }
        },
        "required": [
          "data"
        ]
      },
      "AuthGenerateAppRoleSecretIdRequest": {
        "type": "object",
        "properties": {
          "token_bound_cidrs": {
            "type": "array",
            "description": "Comma-separated string or list of CIDR blocks; if set, specifies blocks of IP addresses which can use the auth tokens generated by this SecretID. Overrides any role-set value but must be a subset.",
            "items": {
              "type": "string"
            }
          },
          "cidr_list": {
            "type": "array",
            "description": "Comma separated string or list of CIDR blocks enforcing secret IDs to be used from specific set of IP addresses. If secret_id_bound_cidrs is set on the role, then the list of CIDR blocks listed here should be a subset of the CIDR blocks listed on the role.",
            "items": {
              "type": "string"
            }
          },
          "metadata": {
            "type": "string",
            "description": "Metadata to be tied to the SecretID. This should be a JSON-formatted string containing the metadata in key-value pairs. This metadata will be set on tokens issued with this SecretID, and is logged in audit logs in plaintext."
          },
          "num_uses": {
            "type": "integer",
            "description": "Number of times this SecretID can be used, after which the SecretID expires. A value of zero will allow unlimited uses. Overrides secret_id_num_uses role option when supplied. May not be higher than role's secret_id_num_uses."
          },
          "ttl": {
            "type": "string",
            "description": "Duration in seconds (3600) or an integer time unit (60m) after which this SecretID expires. A value of zero will allow the SecretID to not expire. Overrides secret_id_ttl role option when supplied. May not be longer than role's secret_id_ttl."
          }
        }
      },
      "VaultApiResponse": {
        "type": "object",
        "properties": {
          "request_id": {
            "type": "string"
          },
          "lease_id": {
            "type": "string"
          },
          "renewable": {
            "type": "boolean"
          },
          "lease_duration": {
            "type": "integer"
          },
          "data": {
            "type": "object"
          },
          "wrap_info": {
            "type": "object"
          },
          "warnings": {
            "type": "array",
            "description": "A list of warnings, e.g. ignored parameters",
            "items": {
              "type": "string"
            }
          },
          "auth": {
            "type": "object"
          },
          "mount_type": {
            "type": "string"
          }
        },
        "required": [
          "request_id"
        ]
      },
      "VaultAuthResponse": {
        "type": "object",
        "properties": {
          "request_id": {
            "type": "string"
          },
          "lease_id": {
            "type": "string"
          },
          "renewable": {
            "type": "boolean"
          },
          "lease_duration": {
            "type": "integer"
          },
          "data": {
            "type": "object"
          },
          "wrap_info": {
            "type": "object"
          },
          "warnings": {
            "type": "array",
            "description": "A list of warnings, e.g. ignored parameters",
            "items": {
              "type": "string"
            }
          },
          "auth": {
            "type": "object",
            "properties": {
              "client_token": {
                "type": "string"
              },
              "accessor": {
                "type": "string"
              },
              "token_policies": {
                "type": "array",
                "description": "A list of policies for the token. This must be a subset of the policies belonging to the token making the request, unless the calling token is root or contains sudo capabilities to auth/token/create. If not specified, defaults to all the policies of the calling token.",
                "items": {
                  "type": "string"
                }
              },
              "metadata": {
                "type": "object",
                "format": "kvpairs",
                "description": "Arbitrary key=value metadata to associate with the token",
                "additionalProperties": {
                  "type": "string"
                }
              },
              "lease_duration": {
                "type": "integer"
              },
              "renewable": {
                "type": "boolean"
              },
              "entity_id": {
                "type": "string"
              },
              "token_type": {
                "type": "string",
                "enum": [
                  "batch",
                  "service",
                  "default",
                  "default-service",
                  "default-batch"
                ]
              },
              "orphan": {
                "type": "boolean"
              },
              "mfa_requirement": {
                "type": "boolean"
              },
              "num_uses": {
                "type": "integer"
              }
            },
            "required": [
              "client_token",
              "accessor",
              "token_policies",
              "lease_duration",
              "token_type",
              "orphan",
              "num_uses",
              "renewable"
            ]
          },
          "mount_type": {
            "type": "string"
          }
        },
        "required": [
          "request_id",
          "auth"
        ]
      },
      "VaultWrappedResponse": {
        "type": "object",
        "properties": {
          "request_id": {
            "type": "string"
          },
          "lease_id": {
            "type": "string"
          },
          "renewable": {
            "type": "boolean"
          },
          "lease_duration": {
            "type": "integer"
          },
          "data": {
            "type": "object"
          },
          "wrap_info": {
            "type": "object",
            "properties": {
              "token": {
                "type": "string"
              },
              "ttl": {
                "type": "integer"
              },
              "creation_time": {
                "type": "string"
              },
              "accessor": {
                "type": "string"
              },
              "creation_path": {
                "type": "string"
              },
              "wrapped_accessor": {
                "type": "string"
              }
            },
            "required": [
              "token",
              "accessor",
              "ttl",
              "creation_time",
              "creation_path",
              "wrapped_accessor"
            ]
          },
          "warnings": {
            "type": "array",
            "description": "A list of warnings, e.g. ignored parameters",
            "items": {
              "type": "string"
            }
          },
          "auth": {
            "type": "object"
          },
          "mount_type": {
            "type": "string"
          }
        },
        "required": [
          "request_id",
          "wrap_info"
        ]
      },
      "VaultErrorsResponse": {
        "type": "object",
        "properties": {
          "errors": {
            "type": "array",
            "description": "List of errors",
            "items": {
              "type": "string"
            }
          }
        }
      }
    },
    "parameters": {
      "VaultTokenHeader": {
        "description": "Vault Token required for authentication",
        "name": "X-Vault-Token",
        "in": "header",
        "schema": {
          "type": "string"
        }
      },
      "WrapTTLHeader": {
        "description": "Use the X-Vault-Wrap-TTL header with any Vault API call where you want to wrap the response.",
        "name": "X-Vault-Wrap-TTL",
        "in": "header",
        "schema": {
          "type": "string"
        }
      }
    }
  }
}
